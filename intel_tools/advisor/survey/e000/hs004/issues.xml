<?xml version='1.0' encoding='UTF-8'?>

<bag xmlns:float="http://www.w3.org/2001/XMLSchema#float" xmlns:int="http://www.w3.org/2001/XMLSchema#int" xmlns:unsignedInt="http://www.w3.org/2001/XMLSchema#unsignedInt" xmlns:unsignedLong="http://www.w3.org/2001/XMLSchema#unsignedLong" int:version="6">
 <issues>
  <issue>
   <unsignedInt:flags>69</unsignedInt:flags>
   <id>issue_assumed_dependency</id>
   <int:severity>2</int:severity>
   <text>The compiler assumed there is an anti-dependency (Write after read - WAR) or true dependency (Read after write - RAW) in the loop. Improve performance by investigating the assumption and handling accordingly. </text>
   <title>Assumed dependency present </title>
   <attributes>
    <float:severity>2</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>2</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>rec_assumed_dependency_run_correctness_c</id>
     <text>There is no confirmation that a real (proven) dependency is present in the loop. To confirm: Run a &lt;a href=&quot;../help/index.htm#GUID-3268707B-9B05-49DA-B657-4511383363E0.htm&quot;&gt;Dependencies analysis&lt;/a&gt;. </text>
     <title>Confirm dependency is real </title>
     <attributes>
      <float:confidence>2</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>3</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>66</unsignedInt:flags>
   <id>compiler_diag_issue_15344</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler detected or assumed a vector dependence in the loop. &lt;br/&gt; &lt;b&gt;C++ Example:&lt;/b&gt; &lt;div class=&quot;sample&quot;&gt;&lt;br/&gt;
int foo(float *A, int n){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int inx = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;float max = A[0];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int i;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (i=0;i &amp;lt; n;i++){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (max &amp;lt; A[i]){&lt;br/&gt;
&lt;b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;max = A[i];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inx = i*i;&lt;/b&gt; &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return inx;&lt;br/&gt;
} &lt;/div&gt;  </text>
   <title>Vector dependence prevents vectorization </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>compiler_diag_rec_15344</id>
     <text>&lt;ul&gt; &lt;li&gt;Rewrite code to remove dependencies.&lt;/li&gt; &lt;li&gt;Run a Dependencies analysis to check if the loop has real dependencies. There are two types of dependencies: &lt;ul&gt; &lt;li&gt;True dependency - Read after write (RAW) &lt;/li&gt; &lt;li&gt;Anti-dependency - Write after read (WAR) &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;If no dependencies exist, use one of the following to tell the compiler it is safe to vectorize: &lt;ul&gt; &lt;li&gt;Directive to prevent all dependencies in the loop &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source Loop &lt;/td&gt; &lt;td&gt;#pragma simd or #pragma omp simd &lt;/td&gt; &lt;td&gt;!DIR$ SIMD or !$OMP SIMD &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;Directive to ignore only vector dependencies (which is safer) &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source Loop &lt;/td&gt; &lt;td&gt;#pragma ivdep&lt;/td&gt; &lt;td&gt;!DIR$ IVDEP &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;&lt;div class=&quot;inplace_sample&quot;&gt;restrict&lt;/div&gt; keyword &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;If anti-dependency exists, use a directive where &lt;div class=&quot;inplace_sample&quot;&gt;k&lt;/div&gt; is smaller than the distance between dependent items in anti-dependency. This enables vectorization, as dependent items are put into different vectors: &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source Loop &lt;/td&gt; &lt;td&gt;#pragma simd vectorlength(k)&lt;/td&gt; &lt;td&gt;!DIR$ SIMD VECTORLENGTH(k) &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Read More C++ Information:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/cdiag15344&quot;&gt;https://software.intel.com/en-us/articles/cdiag15344&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-B25ABCC2-BE6F-4599-AEDF-2434F4676E1B.htm&quot;&gt;ivdep&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-4D8CDB9C-8A96-4CB2-B5E5-3D81003FE4FF.htm&quot;&gt;omp simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-1EA04294-988E-4152-B584-B028FD6FAC48.htm&quot;&gt;simd&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/getting-started-with-intel-composer-xe-2013-compiler-pragmas-and-directives&quot;&gt;Getting Started with Intel Compiler Pragmas and Directives&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor XE Users&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;  </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>3</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>66</unsignedInt:flags>
   <id>compiler_diag_issue_15520</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler did not recognize a search idiom in a loop that may exit early. For example: The loop body contains a conditional exit or GOTO statement followed by calculations.
&lt;/br&gt; &lt;b&gt;C++ Example:&lt;/b&gt; &lt;div class=&quot;sample&quot;&gt;void c15520(float a[], float b[], float c[], int n)&lt;br/&gt;
{&lt;br/&gt;
  int i;&lt;br/&gt;
  for(i=0; i&amp;lt;n; i++) &lt;br/&gt;
  {&lt;br/&gt;
    if(a[i] &amp;lt; 0.) break;&lt;br/&gt;
    c[i] = sqrt(a[i]) * b[i];&lt;br/&gt;
  }&lt;br/&gt;
}&lt;/div&gt;  </text>
   <title>Loop With Early Exits Cannot Be Vectorized Unless It Meets Search Loop Idiom Criteria </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>compiler_diag_rec_15520</id>
     <text>&lt;ul&gt; &lt;li&gt; Split the loop into two loops: &lt;ul&gt; &lt;li&gt;A search loop that has an early exit but still meets the search idiom criteria&lt;/li&gt; &lt;li&gt;A computational loop without early exits&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Ensure the loop has a single entry and a single exit point.&lt;/li&gt; &lt;/ul&gt; &lt;br/&gt; &lt;b&gt;C++ Example:&lt;/b&gt;&lt;/br&gt; Split the loop into a search loop and computational loop. &lt;div class=&quot;sample&quot;&gt;void c15520(float a[], float b[], float c[])&lt;br/&gt;
{&lt;br/&gt;
  int i, j;&lt;br/&gt;
  for(i=0; i&amp;lt;1000; i++) &lt;br/&gt;
  {&lt;br/&gt;
    if(a[i] &amp;lt; 0.) break;&lt;br/&gt;
  }&lt;br/&gt; &lt;br/&gt;
  for(j=0; j&amp;lt;i-1; j++) &lt;br/&gt;
  {&lt;br/&gt;
    c[j] = sqrt(a[j]) * b[j];&lt;br/&gt;
  }&lt;br/&gt;
}&lt;/div&gt; </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>8</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>66</unsignedInt:flags>
   <id>compiler_diag_issue_15520</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler did not recognize a search idiom in a loop that may exit early. For example: The loop body contains a conditional exit or GOTO statement followed by calculations.
&lt;/br&gt; &lt;b&gt;C++ Example:&lt;/b&gt; &lt;div class=&quot;sample&quot;&gt;void c15520(float a[], float b[], float c[], int n)&lt;br/&gt;
{&lt;br/&gt;
  int i;&lt;br/&gt;
  for(i=0; i&amp;lt;n; i++) &lt;br/&gt;
  {&lt;br/&gt;
    if(a[i] &amp;lt; 0.) break;&lt;br/&gt;
    c[i] = sqrt(a[i]) * b[i];&lt;br/&gt;
  }&lt;br/&gt;
}&lt;/div&gt;  </text>
   <title>Loop With Early Exits Cannot Be Vectorized Unless It Meets Search Loop Idiom Criteria </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>compiler_diag_rec_15520</id>
     <text>&lt;ul&gt; &lt;li&gt; Split the loop into two loops: &lt;ul&gt; &lt;li&gt;A search loop that has an early exit but still meets the search idiom criteria&lt;/li&gt; &lt;li&gt;A computational loop without early exits&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Ensure the loop has a single entry and a single exit point.&lt;/li&gt; &lt;/ul&gt; &lt;br/&gt; &lt;b&gt;C++ Example:&lt;/b&gt;&lt;/br&gt; Split the loop into a search loop and computational loop. &lt;div class=&quot;sample&quot;&gt;void c15520(float a[], float b[], float c[])&lt;br/&gt;
{&lt;br/&gt;
  int i, j;&lt;br/&gt;
  for(i=0; i&amp;lt;1000; i++) &lt;br/&gt;
  {&lt;br/&gt;
    if(a[i] &amp;lt; 0.) break;&lt;br/&gt;
  }&lt;br/&gt; &lt;br/&gt;
  for(j=0; j&amp;lt;i-1; j++) &lt;br/&gt;
  {&lt;br/&gt;
    c[j] = sqrt(a[j]) * b[j];&lt;br/&gt;
  }&lt;br/&gt;
}&lt;/div&gt; </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>11</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>69</unsignedInt:flags>
   <id>issue_assumed_dependency</id>
   <int:severity>2</int:severity>
   <text>The compiler assumed there is an anti-dependency (Write after read - WAR) or true dependency (Read after write - RAW) in the loop. Improve performance by investigating the assumption and handling accordingly. </text>
   <title>Assumed dependency present </title>
   <attributes>
    <float:severity>2</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>2</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>rec_assumed_dependency_run_correctness_c</id>
     <text>There is no confirmation that a real (proven) dependency is present in the loop. To confirm: Run a &lt;a href=&quot;../help/index.htm#GUID-3268707B-9B05-49DA-B657-4511383363E0.htm&quot;&gt;Dependencies analysis&lt;/a&gt;. </text>
     <title>Confirm dependency is real </title>
     <attributes>
      <float:confidence>2</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>12</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>66</unsignedInt:flags>
   <id>compiler_diag_issue_15344</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler detected or assumed a vector dependence in the loop. &lt;br/&gt; &lt;b&gt;C++ Example:&lt;/b&gt; &lt;div class=&quot;sample&quot;&gt;&lt;br/&gt;
int foo(float *A, int n){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int inx = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;float max = A[0];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int i;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (i=0;i &amp;lt; n;i++){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (max &amp;lt; A[i]){&lt;br/&gt;
&lt;b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;max = A[i];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inx = i*i;&lt;/b&gt; &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return inx;&lt;br/&gt;
} &lt;/div&gt;  </text>
   <title>Vector dependence prevents vectorization </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>compiler_diag_rec_15344</id>
     <text>&lt;ul&gt; &lt;li&gt;Rewrite code to remove dependencies.&lt;/li&gt; &lt;li&gt;Run a Dependencies analysis to check if the loop has real dependencies. There are two types of dependencies: &lt;ul&gt; &lt;li&gt;True dependency - Read after write (RAW) &lt;/li&gt; &lt;li&gt;Anti-dependency - Write after read (WAR) &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;If no dependencies exist, use one of the following to tell the compiler it is safe to vectorize: &lt;ul&gt; &lt;li&gt;Directive to prevent all dependencies in the loop &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source Loop &lt;/td&gt; &lt;td&gt;#pragma simd or #pragma omp simd &lt;/td&gt; &lt;td&gt;!DIR$ SIMD or !$OMP SIMD &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;Directive to ignore only vector dependencies (which is safer) &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source Loop &lt;/td&gt; &lt;td&gt;#pragma ivdep&lt;/td&gt; &lt;td&gt;!DIR$ IVDEP &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;&lt;div class=&quot;inplace_sample&quot;&gt;restrict&lt;/div&gt; keyword &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;If anti-dependency exists, use a directive where &lt;div class=&quot;inplace_sample&quot;&gt;k&lt;/div&gt; is smaller than the distance between dependent items in anti-dependency. This enables vectorization, as dependent items are put into different vectors: &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source Loop &lt;/td&gt; &lt;td&gt;#pragma simd vectorlength(k)&lt;/td&gt; &lt;td&gt;!DIR$ SIMD VECTORLENGTH(k) &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Read More C++ Information:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/cdiag15344&quot;&gt;https://software.intel.com/en-us/articles/cdiag15344&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-B25ABCC2-BE6F-4599-AEDF-2434F4676E1B.htm&quot;&gt;ivdep&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-4D8CDB9C-8A96-4CB2-B5E5-3D81003FE4FF.htm&quot;&gt;omp simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-1EA04294-988E-4152-B584-B028FD6FAC48.htm&quot;&gt;simd&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/getting-started-with-intel-composer-xe-2013-compiler-pragmas-and-directives&quot;&gt;Getting Started with Intel Compiler Pragmas and Directives&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor XE Users&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;  </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>12</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>101</unsignedInt:flags>
   <id>issue_assumed_dependency</id>
   <int:severity>2</int:severity>
   <text>The compiler assumed there is an anti-dependency (Write after read - WAR) or true dependency (Read after write - RAW) in the loop. Improve performance by investigating the assumption and handling accordingly. </text>
   <title>Assumed dependency present </title>
   <attributes>
    <float:severity>2</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>2</int:confidence>
     <unsignedInt:flags>40</unsignedInt:flags>
     <id>rec_assumed_dependency_run_correctness_c</id>
     <text>There is no confirmation that a real (proven) dependency is present in the loop. To confirm: Run a &lt;a href=&quot;../help/index.htm#GUID-3268707B-9B05-49DA-B657-4511383363E0.htm&quot;&gt;Dependencies analysis&lt;/a&gt;. </text>
     <title>Confirm dependency is real </title>
     <attributes>
      <float:confidence>2</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>14</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>98</unsignedInt:flags>
   <id>compiler_diag_issue_15344</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler detected or assumed a vector dependence in the loop. &lt;br/&gt; &lt;b&gt;C++ Example:&lt;/b&gt; &lt;div class=&quot;sample&quot;&gt;&lt;br/&gt;
int foo(float *A, int n){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int inx = 0;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;float max = A[0];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;int i;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;for (i=0;i &amp;lt; n;i++){&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if (max &amp;lt; A[i]){&lt;br/&gt;
&lt;b&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;max = A[i];&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inx = i*i;&lt;/b&gt; &lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;}&lt;br/&gt;
&amp;nbsp;&amp;nbsp;return inx;&lt;br/&gt;
} &lt;/div&gt;  </text>
   <title>Vector dependence prevents vectorization </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>40</unsignedInt:flags>
     <id>compiler_diag_rec_15344</id>
     <text>&lt;ul&gt; &lt;li&gt;Rewrite code to remove dependencies.&lt;/li&gt; &lt;li&gt;Run a Dependencies analysis to check if the loop has real dependencies. There are two types of dependencies: &lt;ul&gt; &lt;li&gt;True dependency - Read after write (RAW) &lt;/li&gt; &lt;li&gt;Anti-dependency - Write after read (WAR) &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;If no dependencies exist, use one of the following to tell the compiler it is safe to vectorize: &lt;ul&gt; &lt;li&gt;Directive to prevent all dependencies in the loop &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source Loop &lt;/td&gt; &lt;td&gt;#pragma simd or #pragma omp simd &lt;/td&gt; &lt;td&gt;!DIR$ SIMD or !$OMP SIMD &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;Directive to ignore only vector dependencies (which is safer) &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source Loop &lt;/td&gt; &lt;td&gt;#pragma ivdep&lt;/td&gt; &lt;td&gt;!DIR$ IVDEP &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;&lt;div class=&quot;inplace_sample&quot;&gt;restrict&lt;/div&gt; keyword &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;If anti-dependency exists, use a directive where &lt;div class=&quot;inplace_sample&quot;&gt;k&lt;/div&gt; is smaller than the distance between dependent items in anti-dependency. This enables vectorization, as dependent items are put into different vectors: &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source Loop &lt;/td&gt; &lt;td&gt;#pragma simd vectorlength(k)&lt;/td&gt; &lt;td&gt;!DIR$ SIMD VECTORLENGTH(k) &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Read More C++ Information:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/cdiag15344&quot;&gt;https://software.intel.com/en-us/articles/cdiag15344&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-B25ABCC2-BE6F-4599-AEDF-2434F4676E1B.htm&quot;&gt;ivdep&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-4D8CDB9C-8A96-4CB2-B5E5-3D81003FE4FF.htm&quot;&gt;omp simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-1EA04294-988E-4152-B584-B028FD6FAC48.htm&quot;&gt;simd&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/getting-started-with-intel-composer-xe-2013-compiler-pragmas-and-directives&quot;&gt;Getting Started with Intel Compiler Pragmas and Directives&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor XE Users&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;  </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>14</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>98</unsignedInt:flags>
   <id>compiler_diag_issue_15335</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler vectorizer determined the loop will not benefit from vectorization. Common reasons include: &lt;ul&gt; &lt;li&gt;Non-unit stride memory access&lt;/li&gt; &lt;li&gt;Indirect memory access&lt;/li&gt; &lt;li&gt;Low iteration count&lt;/li&gt; &lt;/ul&gt; &lt;b&gt;C++ Example:&lt;/b&gt; The compiler vectorizer determines the cost of creating a vector operand (non-unit stride access in the vector operand creation) is significant when compared to the number/type of computations in which those vector operands are used. &lt;div class=&quot;sample&quot;&gt;&lt;br/&gt;
#include &amp;lt;iostream&amp;gt; &lt;br/&gt;
#define N 100&lt;br/&gt;
struct s1 {&lt;br/&gt;
int a, b, c;&lt;br/&gt;
}&lt;br/&gt;
int main(){&lt;br/&gt;
s1 arr[N], sum;&lt;br/&gt;
&lt;b&gt;for(int i = 0; i &amp;lt; N; i++)&lt;/b&gt;&lt;br/&gt;
{&lt;br/&gt;
&amp;nbsp;&amp;nbsp;sum.a += arr[i].a;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;sum.b += arr[i].b;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;sum.c += arr[i].c;&lt;br/&gt;
}&lt;br/&gt;
std::cout &amp;lt;&amp;lt; sum.a &amp;lt;&amp;lt; &quot;t&quot; &amp;lt;&amp;lt; sum.b &amp;lt;&amp;lt; &quot;t&quot; &amp;lt;&amp;lt; sum.c &amp;lt;&amp;lt; &quot;n&quot;; &lt;br/&gt;
return 0;&lt;br/&gt;
}&lt;/div&gt; </text>
   <title>Loop vectorization possible but seems inefficient </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>40</unsignedInt:flags>
     <id>compiler_diag_rec_15335</id>
     <text>&lt;ul&gt; &lt;li&gt;If you still believe vectorization might result in a speedup, override the compiler cost model using a directive before the loop &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source loop&lt;/td&gt; &lt;td&gt;#pragma vector or #pragma vector always&lt;/td&gt; &lt;td&gt;!DIR$ VECTOR or !DIR$ VECTOR ALWAYS&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; Alternatively, use a compiler option to always vectorize loops. The compiler will still test for dependencies and will not vectorize the loop unless it is safe. &lt;table&gt; &lt;tr&gt; &lt;th&gt;Windows* OS - &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Option&lt;/th&gt; &lt;th&gt;Linux* OS - &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICC/ICPC&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Option&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;/Qvec-threshold0&lt;/td&gt; &lt;td&gt;-vec-threshold0&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;Require vectorization using a directive before the loop. The compiler will not perform a dependency analysis; it is your responsibility to ensure vectorization is safe: &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive &lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;IFORT&lt;/a&gt; Directive &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source loop&lt;/td&gt; &lt;td&gt;#pragma simd or #pragma omp simd &lt;/td&gt; &lt;td&gt;!DIR$ SIMD or !$OMP SIMD &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;Rewrite the data structure/loop to have more regular memory accesses. &lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Read More C++ Information:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/cdiag15335&quot;&gt;https://software.intel.com/en-us/articles/cdiag15335&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-4D8CDB9C-8A96-4CB2-B5E5-3D81003FE4FF.htm&quot;&gt;omp simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-1EA04294-988E-4152-B584-B028FD6FAC48.htm&quot;&gt;simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-C7A523F1-B43D-4AF7-920A-5B155E0823EE.htm&quot;&gt;vec-threshold&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-2B528C72-29B4-4DBC-8B91-EE4D1A03A850.htm&quot;&gt;vector&lt;/a&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/getting-started-with-intel-composer-xe-2013-compiler-pragmas-and-directives&quot;&gt;Getting Started with Intel Compiler Pragmas and Directives&lt;/a&gt; and &lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor XE Users&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;  </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>18</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>66</unsignedInt:flags>
   <id>compiler_diag_issue_15520</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler did not recognize a search idiom in a loop that may exit early. For example: The loop body contains a conditional exit or GOTO statement followed by calculations.
&lt;/br&gt; &lt;b&gt;C++ Example:&lt;/b&gt; &lt;div class=&quot;sample&quot;&gt;void c15520(float a[], float b[], float c[], int n)&lt;br/&gt;
{&lt;br/&gt;
  int i;&lt;br/&gt;
  for(i=0; i&amp;lt;n; i++) &lt;br/&gt;
  {&lt;br/&gt;
    if(a[i] &amp;lt; 0.) break;&lt;br/&gt;
    c[i] = sqrt(a[i]) * b[i];&lt;br/&gt;
  }&lt;br/&gt;
}&lt;/div&gt;  </text>
   <title>Loop With Early Exits Cannot Be Vectorized Unless It Meets Search Loop Idiom Criteria </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>compiler_diag_rec_15520</id>
     <text>&lt;ul&gt; &lt;li&gt; Split the loop into two loops: &lt;ul&gt; &lt;li&gt;A search loop that has an early exit but still meets the search idiom criteria&lt;/li&gt; &lt;li&gt;A computational loop without early exits&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Ensure the loop has a single entry and a single exit point.&lt;/li&gt; &lt;/ul&gt; &lt;br/&gt; &lt;b&gt;C++ Example:&lt;/b&gt;&lt;/br&gt; Split the loop into a search loop and computational loop. &lt;div class=&quot;sample&quot;&gt;void c15520(float a[], float b[], float c[])&lt;br/&gt;
{&lt;br/&gt;
  int i, j;&lt;br/&gt;
  for(i=0; i&amp;lt;1000; i++) &lt;br/&gt;
  {&lt;br/&gt;
    if(a[i] &amp;lt; 0.) break;&lt;br/&gt;
  }&lt;br/&gt; &lt;br/&gt;
  for(j=0; j&amp;lt;i-1; j++) &lt;br/&gt;
  {&lt;br/&gt;
    c[j] = sqrt(a[j]) * b[j];&lt;br/&gt;
  }&lt;br/&gt;
}&lt;/div&gt; </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>20</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>66</unsignedInt:flags>
   <id>compiler_diag_issue_15520</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Cause:&lt;/b&gt; The compiler did not recognize a search idiom in a loop that may exit early. For example: The loop body contains a conditional exit or GOTO statement followed by calculations.
&lt;/br&gt; &lt;b&gt;C++ Example:&lt;/b&gt; &lt;div class=&quot;sample&quot;&gt;void c15520(float a[], float b[], float c[], int n)&lt;br/&gt;
{&lt;br/&gt;
  int i;&lt;br/&gt;
  for(i=0; i&amp;lt;n; i++) &lt;br/&gt;
  {&lt;br/&gt;
    if(a[i] &amp;lt; 0.) break;&lt;br/&gt;
    c[i] = sqrt(a[i]) * b[i];&lt;br/&gt;
  }&lt;br/&gt;
}&lt;/div&gt;  </text>
   <title>Loop With Early Exits Cannot Be Vectorized Unless It Meets Search Loop Idiom Criteria </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>compiler_diag_rec_15520</id>
     <text>&lt;ul&gt; &lt;li&gt; Split the loop into two loops: &lt;ul&gt; &lt;li&gt;A search loop that has an early exit but still meets the search idiom criteria&lt;/li&gt; &lt;li&gt;A computational loop without early exits&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Ensure the loop has a single entry and a single exit point.&lt;/li&gt; &lt;/ul&gt; &lt;br/&gt; &lt;b&gt;C++ Example:&lt;/b&gt;&lt;/br&gt; Split the loop into a search loop and computational loop. &lt;div class=&quot;sample&quot;&gt;void c15520(float a[], float b[], float c[])&lt;br/&gt;
{&lt;br/&gt;
  int i, j;&lt;br/&gt;
  for(i=0; i&amp;lt;1000; i++) &lt;br/&gt;
  {&lt;br/&gt;
    if(a[i] &amp;lt; 0.) break;&lt;br/&gt;
  }&lt;br/&gt; &lt;br/&gt;
  for(j=0; j&amp;lt;i-1; j++) &lt;br/&gt;
  {&lt;br/&gt;
    c[j] = sqrt(a[j]) * b[j];&lt;br/&gt;
  }&lt;br/&gt;
}&lt;/div&gt; </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>21</unsignedLong:rowKey>
  </issue>
  <issue>
   <unsignedInt:flags>66</unsignedInt:flags>
   <id>compiler_diag_issue_15523</id>
   <int:severity>1</int:severity>
   <text>&lt;b&gt;Causes:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;The loop iteration count is not available before the loop executes.&lt;/li&gt; &lt;li&gt;The compiler cannot determine if there is aliasing between all the pointers used inside the loop and loop boundaries.&lt;/li&gt; &lt;/ul&gt; &lt;b&gt;C++ Example 1:&lt;/b&gt; The upper bound of the loop iteration count is controlled by &lt;div class=&quot;inplace_sample&quot;&gt;bar()&lt;/div&gt;, whose implementation is available in this compilation unit. Because the loop iteration count is not available before the loop executes, the compiler cannot determine: &lt;ul&gt; &lt;li&gt;How to map the loop to vector registers&lt;/li&gt; &lt;li&gt;If it needs to create peeled and remainder loops &lt;/li&gt; &lt;li&gt;Where it has enough iterations to saturate at least one vector register&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;sample&quot;&gt; void foo (float *A) {&lt;br/&gt; &amp;nbsp;&amp;nbsp;int i;&lt;br/&gt; &amp;nbsp;&amp;nbsp;int OuterCount = 90;&lt;br/&gt; &amp;nbsp;&amp;nbsp;while (OuterCount &amp;gt; 0) {&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (i = 1; i &amp;lt; bar(int(A[0])); i++) {&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;A[i] = i + 4;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt; &amp;nbsp;&amp;nbsp;OuterCount--;&lt;br/&gt; &amp;nbsp;&amp;nbsp;}&lt;br/&gt; } &lt;/div&gt; &lt;b&gt;C++ Example 2:&lt;/b&gt; The compiler cannot determine if there is aliasing between all the pointers used inside the loop and loop boundaries. &lt;div class=&quot;sample&quot;&gt; struct Dim { int x, y, z; };&lt;br/&gt; Dim dim;&lt;br/&gt; double *B;&lt;br/&gt;&lt;br/&gt; void foo (double* A) {&lt;br/&gt; &amp;nbsp;&amp;nbsp;for (int i = 0; i &amp;lt; dim.x; i++) {&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;A[i] = B[i];&lt;br/&gt; &amp;nbsp;&amp;nbsp}&lt;br/&gt; } &lt;/div&gt; </text>
   <title>Cannot compute loop iteration count before executing the loop </title>
   <attributes>
    <float:severity>1</float:severity>
   </attributes>
   <parameters/>
   <recommendations>
    <recommendation>
     <int:confidence>1</int:confidence>
     <unsignedInt:flags>8</unsignedInt:flags>
     <id>compiler_diag_rec_15523</id>
     <text>&lt;ul&gt; &lt;li&gt; For &lt;b&gt;Example 1&lt;/b&gt;, where the loop iteration count is not available before the loop executes: If the loop iteration count and iterations lower bound can be calculated for the whole loop: &lt;ul&gt; &lt;li&gt;Move the calculation outside the loop using an additional variable.&lt;/li&gt; &lt;li&gt;Rewrite the loop to avoid &lt;div class=&quot;inplace_sample&quot;&gt;goto&lt;/div&gt; statements or other early exits from the loop.&lt;/li&gt; &lt;li&gt;Identify the loop iterations lower bound using a constant.&lt;/li&gt; &lt;/ul&gt; For example, introduce the new &lt;div class=&quot;inplace_sample&quot;&gt;limit&lt;/div&gt; variable: &lt;div class=&quot;sample&quot;&gt; void foo(float *A) {&lt;br/&gt; &amp;nbsp;&amp;nbsp;int i;&lt;br/&gt; &amp;nbsp;&amp;nbsp;int OuterCount = 90;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&lt;b&gt;int limit = bar(int(A[0]));&lt;/b&gt;&lt;br/&gt; &amp;nbsp;&amp;nbsp;while (OuterCount &amp;gt; 0) {&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for (i = 1; i &amp;lt; limit; i++) {&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;A[i] = i + 4;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;OuterCount--;&lt;br/&gt; &amp;nbsp;&amp;nbsp;}&lt;br/&gt; } &lt;/div&gt; &lt;/li&gt; &lt;li&gt; For &lt;b&gt;Example 2&lt;/b&gt;, where the compiler cannot determine if there is aliasing between all the pointers used inside the loop and loop boundaries: Assign the loop boundary value to a local variable. In most cases, this is enough for the compiler to determine aliasing may not occur.&lt;br/&gt; You can use a directive to accomplish the same thing automatically. &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target&lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source loop&lt;/th&gt; &lt;td&gt;#pragma simd or #pragma omp simd&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; Do not use global variables or indirect accesses as loop boundaries unless you also use one of the following: &lt;ul&gt; &lt;li&gt; Directive to ignore vector dependencies &lt;table&gt; &lt;tr&gt; &lt;th&gt;Target&lt;/th&gt; &lt;th&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/intel-advisor-xe-2016-vectorization-advisor-glossary&quot;&gt;ICL/ICC/ICPC&lt;/a&gt; Directive&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Source loop&lt;/th&gt; &lt;td&gt;#pragma ivdep&lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/li&gt; &lt;li&gt;&lt;div class=&quot;inplace_sample&quot;&gt;restrict&lt;/div&gt; keyword.&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;b&gt;Read More:&lt;/b&gt; &lt;ul&gt; &lt;li&gt;C++ information at &lt;a href=&quot;https://software.intel.com/en-us/articles/cdiag15523&quot;&gt;https://software.intel.com/en-us/articles/cdiag15523&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;C++/17/index.htm#GUID-B25ABCC2-BE6F-4599-AEDF-2434F4676E1B.htm&quot;&gt;ivdep&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-4D8CDB9C-8A96-4CB2-B5E5-3D81003FE4FF.htm&quot;&gt;omp simd&lt;/a&gt;, &lt;a href=&quot;C++/17/index.htm#GUID-1EA04294-988E-4152-B584-B028FD6FAC48.htm&quot;&gt;simd&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/vectorization-resources-advisor&quot;&gt;Vectorization Resources for Intel&amp;reg; Advisor XE Users&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; </text>
     <title>Recommendations </title>
     <attributes>
      <float:confidence>1</float:confidence>
     </attributes>
     <parameters/>
    </recommendation>
   </recommendations>
   <unsignedLong:rowKey>22</unsignedLong:rowKey>
  </issue>
 </issues>
 <traits/>
</bag>
